cmake_minimum_required(VERSION 3.15...3.27)
project(AM-QADF LANGUAGES CXX VERSION 1.0.0)

# Set C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Build options
option(BUILD_PYTHON_BINDINGS "Build Python bindings" ON)
option(BUILD_TESTS "Build tests" ON)
option(ENABLE_SANITIZERS "Enable sanitizers (Address, Undefined Behavior)" OFF)
option(ENABLE_COVERAGE "Enable coverage reporting" OFF)
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)
option(ENABLE_UBSAN "Enable UndefinedBehaviorSanitizer" OFF)
option(ENABLE_MSAN "Enable MemorySanitizer" OFF)
option(ENABLE_TSAN "Enable ThreadSanitizer" OFF)
option(ENABLE_PROFILING "Enable profiling support" OFF)
option(ENABLE_BENCHMARKS "Enable performance benchmarks" ON)
option(USE_SYSTEM_LIBS "Use system libraries instead of conda libraries (recommended for C++)" OFF)
option(FORCE_SYSTEM_COMPILER "Force use of system compiler instead of conda compiler" OFF)

# Add compiler flags for better performance and warnings
if (CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(-Wall -Wextra -pedantic -O3 -march=native -funroll-loops)
    if(ENABLE_PROFILING)
        add_compile_options(-pg)
    endif()
elseif (CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
    # MSVC flags - different for Debug vs Release
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        add_compile_options(/W4 /arch:AVX2 /fp:fast)
    else()
        add_compile_options(/W4 /Ox /arch:AVX2 /fp:fast)
    endif()
    if(ENABLE_PROFILING)
        add_compile_options(/Zi)
    endif()
endif()

# Sanitizer support
if(ENABLE_SANITIZERS OR ENABLE_ASAN OR ENABLE_UBSAN OR ENABLE_MSAN OR ENABLE_TSAN)
    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
        set(SANITIZER_FLAGS "")
        if(ENABLE_ASAN OR ENABLE_SANITIZERS)
            list(APPEND SANITIZER_FLAGS "-fsanitize=address")
        endif()
        if(ENABLE_UBSAN OR ENABLE_SANITIZERS)
            list(APPEND SANITIZER_FLAGS "-fsanitize=undefined")
        endif()
        if(ENABLE_MSAN)
            list(APPEND SANITIZER_FLAGS "-fsanitize=memory")
        endif()
        if(ENABLE_TSAN)
            list(APPEND SANITIZER_FLAGS "-fsanitize=thread")
        endif()
        add_compile_options(${SANITIZER_FLAGS})
        add_link_options(${SANITIZER_FLAGS})
        message(STATUS "Sanitizers enabled: ${SANITIZER_FLAGS}")
    else()
        message(FATAL_ERROR "Sanitizers are only supported with GCC/Clang. Current compiler: ${CMAKE_CXX_COMPILER_ID}")
    endif()
endif()

# Coverage support
if(ENABLE_COVERAGE)
    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
        add_compile_options(--coverage)
        add_link_options(--coverage)
        message(STATUS "Coverage reporting enabled")
    else()
        message(FATAL_ERROR "Coverage is only supported with GCC/Clang. Current compiler: ${CMAKE_CXX_COMPILER_ID}")
    endif()
endif()

# Add CMake modules path
list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/tools/cmake")

# Find Python and pybind11
find_package(Python3 3.6 COMPONENTS Interpreter Development REQUIRED)

# Find pybind11 using Python (works for both Docker and local)
execute_process(
    COMMAND python -c "import pybind11; print(pybind11.get_cmake_dir())"
    OUTPUT_VARIABLE PYBIND11_CMAKE_DIR
    OUTPUT_STRIP_TRAILING_WHITESPACE
    RESULT_VARIABLE PYBIND11_CMAKE_RESULT
)

if(PYBIND11_CMAKE_RESULT EQUAL 0)
    set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};${PYBIND11_CMAKE_DIR}")
    message(STATUS "Found pybind11 cmake dir: ${PYBIND11_CMAKE_DIR}")
else()
    # Fallback: try common locations
    if(WIN32)
        set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};C:/Users/kanha/anaconda3/envs/doienv/Lib/site-packages/pybind11/share/cmake/pybind11")
        set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};C:/Users/kanha/anaconda3/envs/doienv/Library/share/cmake/pybind11")
    else()
        set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};/usr/local/lib/python3.11/site-packages/pybind11/share/cmake/pybind11")
        set(CMAKE_PREFIX_PATH "${CMAKE_PREFIX_PATH};/usr/lib/python3.11/site-packages/pybind11/share/cmake/pybind11")
    endif()
    message(STATUS "Using fallback pybind11 paths")
endif()

# Find pybind11
find_package(pybind11 REQUIRED)
find_package(Threads REQUIRED)

# Find additional dependencies
find_package(OpenVDB REQUIRED)

# Find ITK (REQUIRED - CT scan reading needs ITK)
# Priority 1: Check third_party/ITK/install (project-local build)
set(ITK_THIRD_PARTY_DIR "${CMAKE_SOURCE_DIR}/third_party/ITK/install/lib/cmake/ITK-6.0")
if(EXISTS "${ITK_THIRD_PARTY_DIR}/ITKConfig.cmake")
    message(STATUS "Found ITK in third_party: ${ITK_THIRD_PARTY_DIR}")
    set(ITK_DIR "${ITK_THIRD_PARTY_DIR}" CACHE PATH "ITK CMake config directory" FORCE)
    find_package(ITK REQUIRED PATHS "${ITK_THIRD_PARTY_DIR}" NO_DEFAULT_PATH)
else()
    # Priority 2: Try system/conda installation
    message(STATUS "ITK not found in third_party, searching system/conda...")
    find_package(ITK REQUIRED)
endif()

if(NOT ITK_FOUND)
    message(FATAL_ERROR "ITK is REQUIRED but not found!")
    message(STATUS "  Expected location: ${CMAKE_SOURCE_DIR}/third_party/ITK/install/lib/cmake/ITK-6.0/ITKConfig.cmake")
    message(STATUS "  Install ITK:")
    message(STATUS "    - Build from source: See docs/Infrastructure/INSTALL_DEPENDENCIES.md")
    message(STATUS "    - Or: conda install -c conda-forge itk")
    message(STATUS "  Set ITK_DIR to your ITK build directory:")
    message(STATUS "    export ITK_DIR=/path/to/ITK/build/lib/cmake/ITK-6.0")
    message(STATUS "    cmake -DITK_DIR=/path/to/ITK/build/lib/cmake/ITK-6.0 ..")
endif()

# Find Eigen (header-only)
# Check third_party first (project-local)
set(EIGEN3_ROOT "${CMAKE_SOURCE_DIR}/third_party/eigen" CACHE PATH "Eigen root directory")
if(EXISTS "${EIGEN3_ROOT}/Eigen")
    set(EIGEN3_INCLUDE_DIR "${EIGEN3_ROOT}" CACHE PATH "Eigen include directory")
    set(EIGEN3_FOUND TRUE CACHE BOOL "Eigen found")
    message(STATUS "Found Eigen in third_party: ${EIGEN3_INCLUDE_DIR}")
else()
    # Also check one level up (in case build is in subdirectory)
    set(EIGEN3_ROOT "${CMAKE_SOURCE_DIR}/../third_party/eigen" CACHE PATH "Eigen root directory" FORCE)
    if(EXISTS "${EIGEN3_ROOT}/Eigen")
        set(EIGEN3_INCLUDE_DIR "${EIGEN3_ROOT}" CACHE PATH "Eigen include directory")
        set(EIGEN3_FOUND TRUE CACHE BOOL "Eigen found")
        message(STATUS "Found Eigen in third_party: ${EIGEN3_INCLUDE_DIR}")
    else()
        # Try system/conda installation
        find_package(Eigen3 QUIET)
        if(Eigen3_FOUND)
            set(EIGEN3_INCLUDE_DIR ${EIGEN3_INCLUDE_DIR} CACHE PATH "Eigen include directory")
            set(EIGEN3_FOUND TRUE CACHE BOOL "Eigen found")
            message(STATUS "Found Eigen: ${EIGEN3_INCLUDE_DIR} (system/conda)")
        else()
            message(WARNING "Eigen not found - Savitzky-Golay and RBF interpolation will be disabled")
            message(STATUS "  Hint: Clone Eigen to third_party/eigen or install via conda")
            set(EIGEN3_FOUND FALSE CACHE BOOL "Eigen found")
        endif()
    endif()
endif()

# Find KFR (header-only)
# TEMPORARILY DISABLED due to compilation errors with current compiler/KFR version
# TODO: Re-enable once KFR compatibility issues are resolved
set(KFR_FOUND FALSE CACHE BOOL "KFR found" FORCE)
message(STATUS "KFR disabled - FFT and optimized filters will use fallback implementations")
# Check third_party first (project-local)
# set(KFR_ROOT "${CMAKE_SOURCE_DIR}/third_party/kfr" CACHE PATH "KFR root directory")
# if(EXISTS "${KFR_ROOT}/include/kfr")
#     set(KFR_INCLUDE_DIR "${KFR_ROOT}/include" CACHE PATH "KFR include directory")
#     set(KFR_FOUND TRUE CACHE BOOL "KFR found")
#     message(STATUS "Found KFR in third_party: ${KFR_INCLUDE_DIR}")
# else()
#     # Also check one level up (in case build is in subdirectory)
#     set(KFR_ROOT "${CMAKE_SOURCE_DIR}/../third_party/kfr" CACHE PATH "KFR root directory" FORCE)
#     if(EXISTS "${KFR_ROOT}/include/kfr")
#         set(KFR_INCLUDE_DIR "${KFR_ROOT}/include" CACHE PATH "KFR include directory")
#         set(KFR_FOUND TRUE CACHE BOOL "KFR found")
#         message(STATUS "Found KFR in third_party: ${KFR_INCLUDE_DIR}")
#     else()
#         message(WARNING "KFR not found - FFT and optimized filters will be disabled")
#         message(STATUS "  Hint: Clone KFR to third_party/kfr")
#         message(STATUS "  Example: git clone https://github.com/kfrlib/kfr.git third_party/kfr")
#         set(KFR_FOUND FALSE CACHE BOOL "KFR found")
#     endif()
# endif()

# Find mongocxx - try to locate config file in install directory first (third_party build or cache)
set(MONGOCXX_INSTALL_DIR "${CMAKE_SOURCE_DIR}/third_party/mongo-cxx-driver/install")
if(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongocxx-4.1.4/mongocxx-config.cmake")
    set(mongocxx_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongocxx-4.1.4")
    message(STATUS "Found mongocxx config in: ${mongocxx_DIR}")
elseif(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongocxx/mongocxx-config.cmake")
    set(mongocxx_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongocxx")
    message(STATUS "Found mongocxx config in: ${mongocxx_DIR}")
endif()

# mongocxx requires mongoc (C driver) - try to find it in multiple locations
# Priority 1: Same install directory as mongocxx (if built together)
if(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongoc-1.0/mongoc-config.cmake")
    set(mongoc_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongoc-1.0")
    message(STATUS "Found mongoc config in install directory: ${mongoc_DIR}")
elseif(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongoc/mongoc-config.cmake")
    set(mongoc_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/mongoc")
    message(STATUS "Found mongoc config in install directory: ${mongoc_DIR}")
# Priority 2: System locations (if installed via apt-get)
elseif(EXISTS "/usr/lib/x86_64-linux-gnu/cmake/mongoc-1.0/mongoc-config.cmake")
    set(mongoc_DIR "/usr/lib/x86_64-linux-gnu/cmake/mongoc-1.0")
    message(STATUS "Found mongoc config in system: ${mongoc_DIR}")
elseif(EXISTS "/usr/lib/cmake/mongoc-1.0/mongoc-config.cmake")
    set(mongoc_DIR "/usr/lib/cmake/mongoc-1.0")
    message(STATUS "Found mongoc config in system: ${mongoc_DIR}")
elseif(EXISTS "/usr/local/lib/cmake/mongoc-1.0/mongoc-config.cmake")
    set(mongoc_DIR "/usr/local/lib/cmake/mongoc-1.0")
    message(STATUS "Found mongoc config in system: ${mongoc_DIR}")
# Priority 3: Conda environment (if available)
elseif(DEFINED ENV{CONDA_PREFIX})
    if(EXISTS "$ENV{CONDA_PREFIX}/lib/cmake/mongoc-1.0/mongoc-config.cmake")
        set(mongoc_DIR "$ENV{CONDA_PREFIX}/lib/cmake/mongoc-1.0")
        message(STATUS "Found mongoc config in conda: ${mongoc_DIR}")
    elseif(EXISTS "$ENV{CONDA_PREFIX}/lib/cmake/mongoc/mongoc-config.cmake")
        set(mongoc_DIR "$ENV{CONDA_PREFIX}/lib/cmake/mongoc")
        message(STATUS "Found mongoc config in conda: ${mongoc_DIR}")
    endif()
endif()

# Try to find mongoc first (required by mongocxx)
# Use find_package to search broadly, then check specific locations
find_package(mongoc QUIET)
if(NOT mongoc_FOUND)
    # If mongoc_DIR was set above, use it explicitly
    if(DEFINED mongoc_DIR)
        find_package(mongoc QUIET PATHS ${mongoc_DIR} NO_DEFAULT_PATH)
    endif()
    
    # If still not found, try searching in common system locations
    if(NOT mongoc_FOUND)
        find_package(mongoc QUIET PATHS
            /usr/lib/x86_64-linux-gnu/cmake
            /usr/lib/cmake
            /usr/local/lib/cmake
            ${MONGOCXX_INSTALL_DIR}/lib/cmake
        )
    endif()
endif()

# mongocxx also requires bsoncxx - try to find it in the same install directory
# Priority 1: Same install directory as mongocxx (if built together)
if(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/bsoncxx-4.1.4/bsoncxx-config.cmake")
    set(bsoncxx_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/bsoncxx-4.1.4")
    message(STATUS "Found bsoncxx config in install directory: ${bsoncxx_DIR}")
elseif(EXISTS "${MONGOCXX_INSTALL_DIR}/lib/cmake/bsoncxx/bsoncxx-config.cmake")
    set(bsoncxx_DIR "${MONGOCXX_INSTALL_DIR}/lib/cmake/bsoncxx")
    message(STATUS "Found bsoncxx config in install directory: ${bsoncxx_DIR}")
# Priority 2: System locations (if installed via apt-get)
elseif(EXISTS "/usr/lib/x86_64-linux-gnu/cmake/bsoncxx-4.1.4/bsoncxx-config.cmake")
    set(bsoncxx_DIR "/usr/lib/x86_64-linux-gnu/cmake/bsoncxx-4.1.4")
    message(STATUS "Found bsoncxx config in system: ${bsoncxx_DIR}")
elseif(EXISTS "/usr/lib/cmake/bsoncxx-4.1.4/bsoncxx-config.cmake")
    set(bsoncxx_DIR "/usr/lib/cmake/bsoncxx-4.1.4")
    message(STATUS "Found bsoncxx config in system: ${bsoncxx_DIR}")
elseif(EXISTS "/usr/local/lib/cmake/bsoncxx-4.1.4/bsoncxx-config.cmake")
    set(bsoncxx_DIR "/usr/local/lib/cmake/bsoncxx-4.1.4")
    message(STATUS "Found bsoncxx config in system: ${bsoncxx_DIR}")
endif()

# Try to find bsoncxx (required by mongocxx)
find_package(bsoncxx QUIET)
if(NOT bsoncxx_FOUND AND DEFINED bsoncxx_DIR)
    find_package(bsoncxx QUIET PATHS ${bsoncxx_DIR} NO_DEFAULT_PATH)
endif()
if(NOT bsoncxx_FOUND)
    find_package(bsoncxx QUIET PATHS
        /usr/lib/x86_64-linux-gnu/cmake
        /usr/lib/cmake
        /usr/local/lib/cmake
        ${MONGOCXX_INSTALL_DIR}/lib/cmake
    )
endif()

find_package(mongocxx REQUIRED)
if(NOT mongocxx_FOUND)
    message(FATAL_ERROR "mongocxx not found - MongoDB queries are required")
    message(STATUS "To install mongocxx:")
    message(STATUS "  - Build from source in third_party/: See docs/Infrastructure/INSTALL_DEPENDENCIES_WSL.md")
    message(STATUS "  - Prerequisites: sudo apt-get install libmongoc-dev libbson-dev")
    message(STATUS "  - Alternative (may not work): sudo apt-get install libmongocxx-dev libbsoncxx-dev")
    message(STATUS "  - Or: conda install -c conda-forge mongocxx bsoncxx (may not be available)")
endif()

# Verify mongoc was found (required by mongocxx)
if(NOT mongoc_FOUND)
    message(FATAL_ERROR "mongoc (C driver) not found - mongocxx requires it!")
    message(STATUS "  mongocxx was found but its dependency mongoc is missing.")
    message(STATUS "")
    message(STATUS "  If you installed libmongoc-dev, mongoc might be in a non-standard location.")
    message(STATUS "  Try to locate mongoc-config.cmake:")
    message(STATUS "    find /usr -name 'mongoc-config.cmake' 2>/dev/null")
    message(STATUS "    find /usr/local -name 'mongoc-config.cmake' 2>/dev/null")
    message(STATUS "")
    message(STATUS "  If found, set mongoc_DIR when running cmake:")
    message(STATUS "    cmake -Dmongoc_DIR=/path/to/mongoc/cmake ..")
    message(STATUS "")
    message(STATUS "  Or install mongoc via:")
    message(STATUS "    sudo apt-get update")
    message(STATUS "    sudo apt-get install libmongoc-dev libbson-dev")
    message(STATUS "")
    message(STATUS "  Or if mongoc was built alongside mongocxx, check:")
    message(STATUS "    ${MONGOCXX_INSTALL_DIR}/lib/cmake/")
    message(STATUS "")
    message(STATUS "  After installing, run: rm -rf build && cmake ..")
endif()

# Verify bsoncxx was found (required by mongocxx)
if(NOT bsoncxx_FOUND)
    message(FATAL_ERROR "bsoncxx not found - mongocxx requires it!")
    message(STATUS "  mongocxx was found but its dependency bsoncxx is missing.")
    message(STATUS "")
    message(STATUS "  bsoncxx should be in the same install directory as mongocxx.")
    message(STATUS "  Try to locate bsoncxx-config.cmake:")
    message(STATUS "    find ${MONGOCXX_INSTALL_DIR} -name 'bsoncxx-config.cmake' 2>/dev/null")
    message(STATUS "    find /usr -name 'bsoncxx-config.cmake' 2>/dev/null")
    message(STATUS "")
    message(STATUS "  If found, set bsoncxx_DIR when running cmake:")
    message(STATUS "    cmake -Dbsoncxx_DIR=/path/to/bsoncxx/cmake ..")
    message(STATUS "")
    message(STATUS "  Or if bsoncxx was built alongside mongocxx, check:")
    message(STATUS "    ${MONGOCXX_INSTALL_DIR}/lib/cmake/")
    message(STATUS "")
    message(STATUS "  After installing, run: rm -rf build && cmake ..")
endif()

# Find TBB (Threading Building Blocks) - required by OpenVDB
# CRITICAL: TBB must be accessible to the compiler, found and verified on filesystem
# Clear any cached TBB values to ensure fresh search
unset(TBB_INCLUDE_DIR CACHE)
unset(TBB_FOUND CACHE)

# Detect if using conda compiler (conda compilers ignore /usr/include)
set(USING_CONDA_COMPILER FALSE)
if(CMAKE_CXX_COMPILER MATCHES "conda" OR CMAKE_CXX_COMPILER MATCHES "miniconda" OR CMAKE_CXX_COMPILER MATCHES "anaconda")
    if(NOT FORCE_SYSTEM_COMPILER)
        set(USING_CONDA_COMPILER TRUE)
        message(STATUS "Detected conda compiler: ${CMAKE_CXX_COMPILER}")
        if(USE_SYSTEM_LIBS)
            message(WARNING "USE_SYSTEM_LIBS=ON with conda compiler - conda compilers cannot reliably access /usr/include")
            message(STATUS "  RECOMMENDED: Use system compiler instead:")
            message(STATUS "    CC=gcc CXX=g++ cmake -DUSE_SYSTEM_LIBS=ON ..")
            message(STATUS "  Will attempt -isystem flags, but may still fail")
        else()
            message(STATUS "  Conda compilers ignore /usr/include - will use conda TBB")
            message(STATUS "  To use system libraries, use system compiler: CC=gcc CXX=g++ cmake -DUSE_SYSTEM_LIBS=ON ..")
        endif()
    else()
        message(STATUS "FORCE_SYSTEM_COMPILER=ON: Treating conda compiler as system compiler")
    endif()
endif()

# Determine TBB search strategy
if(USE_SYSTEM_LIBS)
    set(PREFER_SYSTEM_TBB TRUE)
    message(STATUS "USE_SYSTEM_LIBS=ON: Preferring system TBB over conda TBB")
else()
    set(PREFER_SYSTEM_TBB FALSE)
endif()

find_package(TBB QUIET)
if(NOT TBB_FOUND)
    # Helper function to check conda TBB
    function(find_conda_tbb)
        set(TBB_INCLUDE_DIR_CONDA)
        if(DEFINED ENV{CONDA_PREFIX})
            # Direct file check first (most reliable)
            if(EXISTS "$ENV{CONDA_PREFIX}/include/tbb/blocked_range.h")
                set(TBB_INCLUDE_DIR_CONDA "$ENV{CONDA_PREFIX}/include" PARENT_SCOPE)
                return()
            endif()
            # Check for oneapi/tbb
            if(EXISTS "$ENV{CONDA_PREFIX}/include/oneapi/tbb/blocked_range.h")
                set(TBB_INCLUDE_DIR_CONDA "$ENV{CONDA_PREFIX}/include" PARENT_SCOPE)
                set(TBB_USE_ONEAPI TRUE PARENT_SCOPE)
                return()
            endif()
            # Try find_path
            find_path(TBB_INCLUDE_DIR_CONDA tbb/blocked_range.h
                PATHS $ENV{CONDA_PREFIX}/include
                NO_DEFAULT_PATH
            )
            if(TBB_INCLUDE_DIR_CONDA)
                set(TBB_INCLUDE_DIR_CONDA ${TBB_INCLUDE_DIR_CONDA} PARENT_SCOPE)
            endif()
        endif()
    endfunction()
    
    # Search strategy: USE_SYSTEM_LIBS determines priority
    if(PREFER_SYSTEM_TBB)
        # Strategy: System TBB first, then conda as fallback
        message(STATUS "USE_SYSTEM_LIBS=ON: Searching system TBB first")
        find_path(TBB_INCLUDE_DIR tbb/blocked_range.h
            PATHS /usr/include /usr/local/include
            NO_DEFAULT_PATH
        )
        if(TBB_INCLUDE_DIR)
            message(STATUS "Found TBB in system: ${TBB_INCLUDE_DIR}")
        else()
            # Fallback to conda
            find_conda_tbb()
            if(TBB_INCLUDE_DIR_CONDA)
                set(TBB_INCLUDE_DIR ${TBB_INCLUDE_DIR_CONDA})
                message(STATUS "Found TBB in conda (fallback): ${TBB_INCLUDE_DIR}")
            endif()
        endif()
    else()
        # Strategy: Conda TBB first (for conda compilers), then system
        if(DEFINED ENV{CONDA_PREFIX})
            find_conda_tbb()
            if(TBB_INCLUDE_DIR_CONDA)
                set(TBB_INCLUDE_DIR ${TBB_INCLUDE_DIR_CONDA})
                message(STATUS "Found TBB in conda environment: ${TBB_INCLUDE_DIR}")
            endif()
        endif()
        
        # System TBB as fallback (only if not using conda compiler, or if USE_SYSTEM_LIBS allows it)
        if(NOT TBB_INCLUDE_DIR AND (NOT USING_CONDA_COMPILER OR PREFER_SYSTEM_TBB))
            find_path(TBB_INCLUDE_DIR tbb/blocked_range.h
                PATHS /usr/include /usr/local/include
                NO_DEFAULT_PATH
            )
            if(TBB_INCLUDE_DIR)
                message(STATUS "Found TBB in system: ${TBB_INCLUDE_DIR}")
                if(USING_CONDA_COMPILER)
                    message(WARNING "Using system TBB with conda compiler - may require -isystem flags")
                endif()
            endif()
        endif()
    endif()
    
    # Last resort: try without NO_DEFAULT_PATH
    if(NOT TBB_INCLUDE_DIR)
        find_path(TBB_INCLUDE_DIR tbb/blocked_range.h)
    endif()
    
    if(TBB_INCLUDE_DIR)
        set(TBB_FOUND TRUE CACHE BOOL "TBB found")
        set(TBB_INCLUDE_DIR "${TBB_INCLUDE_DIR}" CACHE PATH "TBB include directory")
        message(STATUS "Using TBB include directory: ${TBB_INCLUDE_DIR}")
    else()
        if(USING_CONDA_COMPILER AND NOT PREFER_SYSTEM_TBB)
            message(FATAL_ERROR "TBB not found in conda environment but using conda compiler!")
            message(STATUS "  Install: conda install -c conda-forge tbb tbb-devel")
            message(STATUS "  Or use system libraries: cmake -DUSE_SYSTEM_LIBS=ON ..")
        else()
            message(WARNING "TBB not found - OpenVDB requires TBB")
            message(STATUS "  Install: sudo apt-get install libtbb-dev")
            message(STATUS "  Or: conda install -c conda-forge tbb")
        endif()
        set(TBB_FOUND FALSE CACHE BOOL "TBB found")
    endif()
endif()

# Verify TBB headers are actually accessible to the compiler
# CRITICAL: This check must pass or compilation will fail when OpenVDB includes TBB
if(TBB_FOUND OR TBB_INCLUDE_DIR)
    include(CheckIncludeFileCXX)
    
    # First try without any flags (normal case)
    set(CMAKE_REQUIRED_INCLUDES ${TBB_INCLUDE_DIR})
    unset(CMAKE_REQUIRED_FLAGS)
    check_include_file_cxx("tbb/blocked_range.h" TBB_HEADER_ACCESSIBLE)
    
    if(NOT TBB_HEADER_ACCESSIBLE)
        # Try with explicit include path flag
        set(CMAKE_REQUIRED_INCLUDES)
        set(CMAKE_REQUIRED_FLAGS "-I${TBB_INCLUDE_DIR}")
        check_include_file_cxx("tbb/blocked_range.h" TBB_HEADER_ACCESSIBLE_WITH_FLAG)
        
        if(NOT TBB_HEADER_ACCESSIBLE_WITH_FLAG)
            # Last resort: try with both CMAKE_REQUIRED_INCLUDES and flag
            set(CMAKE_REQUIRED_INCLUDES ${TBB_INCLUDE_DIR})
            set(CMAKE_REQUIRED_FLAGS "-I${TBB_INCLUDE_DIR}")
            check_include_file_cxx("tbb/blocked_range.h" TBB_HEADER_ACCESSIBLE_WITH_BOTH)
            
            if(NOT TBB_HEADER_ACCESSIBLE_WITH_BOTH)
                # If USE_SYSTEM_LIBS is ON and using conda compiler, try -isystem flag
                set(TBB_HEADER_ACCESSIBLE_WITH_ISYSTEM FALSE)
                if(USE_SYSTEM_LIBS AND USING_CONDA_COMPILER AND TBB_INCLUDE_DIR MATCHES "^/usr")
                    set(CMAKE_REQUIRED_INCLUDES)
                    set(CMAKE_REQUIRED_FLAGS "-isystem ${TBB_INCLUDE_DIR}")
                    check_include_file_cxx("tbb/blocked_range.h" TBB_HEADER_ACCESSIBLE_WITH_ISYSTEM)
                    if(TBB_HEADER_ACCESSIBLE_WITH_ISYSTEM)
                        message(STATUS "TBB headers accessible with -isystem flag (USE_SYSTEM_LIBS=ON)")
                        set(TBB_NEEDS_EXPLICIT_INCLUDE TRUE CACHE BOOL "TBB needs explicit include flag")
                        set(TBB_NEEDS_ISYSTEM TRUE CACHE BOOL "TBB needs -isystem flag for conda compiler")
                    endif()
                endif()
                
                if(NOT TBB_HEADER_ACCESSIBLE_WITH_ISYSTEM)
                    # This is a fatal error - compilation will definitely fail
                    message(FATAL_ERROR "TBB headers found at ${TBB_INCLUDE_DIR} but compiler CANNOT access them!")
                    message(FATAL_ERROR "  Compiler: ${CMAKE_CXX_COMPILER}")
                    message(FATAL_ERROR "  TBB header path: ${TBB_INCLUDE_DIR}/tbb/blocked_range.h")
                    if(EXISTS "${TBB_INCLUDE_DIR}/tbb/blocked_range.h")
                        message(FATAL_ERROR "  File exists: YES")
                    else()
                        message(FATAL_ERROR "  File exists: NO")
                    endif()
                    message(FATAL_ERROR "")
                    message(FATAL_ERROR "================================================================================")
                    message(FATAL_ERROR "TBB headers found but compiler CANNOT access them!")
                    message(FATAL_ERROR "================================================================================")
                    if(USING_CONDA_COMPILER AND TBB_INCLUDE_DIR MATCHES "^/usr")
                        message(FATAL_ERROR "  PROBLEM: Conda compilers have restricted sysroot and cannot access /usr/include")
                        message(FATAL_ERROR "           Even -isystem flags may not work reliably.")
                        message(FATAL_ERROR "")
                        if(USE_SYSTEM_LIBS)
                            message(FATAL_ERROR "  SOLUTION (RECOMMENDED): Use system compiler with system libraries:")
                            message(FATAL_ERROR "    cd build")
                            message(FATAL_ERROR "    rm -rf *")
                            message(FATAL_ERROR "    CC=gcc CXX=g++ cmake -DUSE_SYSTEM_LIBS=ON ..")
                            message(FATAL_ERROR "")
                            message(FATAL_ERROR "  ALTERNATIVE: Use conda TBB with conda compiler:")
                            message(FATAL_ERROR "    conda install -c conda-forge tbb tbb-devel")
                            message(FATAL_ERROR "    cd build && rm -rf * && cmake ..  # (without USE_SYSTEM_LIBS)")
                        else()
                            message(FATAL_ERROR "  SOLUTION: Install conda TBB:")
                            message(FATAL_ERROR "    conda install -c conda-forge tbb tbb-devel")
                            message(FATAL_ERROR "    cd build && rm -rf * && cmake ..")
                            message(FATAL_ERROR "")
                            message(FATAL_ERROR "  OR use system compiler with system libraries:")
                            message(FATAL_ERROR "    CC=gcc CXX=g++ cmake -DUSE_SYSTEM_LIBS=ON ..")
                        endif()
                    elseif(DEFINED ENV{CONDA_PREFIX})
                        if(EXISTS "$ENV{CONDA_PREFIX}/include/tbb/blocked_range.h")
                            message(FATAL_ERROR "  Conda TBB exists: YES")
                            message(FATAL_ERROR "  SOLUTION: Clear cache: cd build && rm -rf * && cmake ..")
                        else()
                            message(FATAL_ERROR "  Conda TBB exists: NO")
                            message(FATAL_ERROR "  SOLUTION: Install: conda install -c conda-forge tbb tbb-devel")
                        endif()
                    else()
                        message(FATAL_ERROR "  SOLUTION: Install system TBB:")
                        message(FATAL_ERROR "    sudo apt-get install libtbb-dev")
                    endif()
                    message(FATAL_ERROR "")
                endif()
            else()
                message(STATUS "TBB headers accessible with both include dir and explicit flag")
                set(TBB_NEEDS_EXPLICIT_INCLUDE TRUE CACHE BOOL "TBB needs explicit include flag")
            endif()
        else()
            message(STATUS "TBB headers accessible with explicit -I flag")
            set(TBB_NEEDS_EXPLICIT_INCLUDE TRUE CACHE BOOL "TBB needs explicit include flag")
        endif()
    else()
        message(STATUS "TBB headers verified accessible to compiler")
        set(TBB_NEEDS_EXPLICIT_INCLUDE FALSE CACHE BOOL "TBB needs explicit include flag")
    endif()
    
    # Clean up
    unset(CMAKE_REQUIRED_INCLUDES)
    unset(CMAKE_REQUIRED_FLAGS)
endif()

# OpenMP support (optional but recommended for performance)
if(MSVC)
    message(STATUS "MSVC detected - OpenMP is built-in")
    set(OPENMP_AVAILABLE TRUE)
else()
    find_package(OpenMP QUIET)
    if(OpenMP_CXX_FOUND)
        message(STATUS "OpenMP found: ${OpenMP_CXX_VERSION}")
        set(OPENMP_AVAILABLE TRUE)
    else()
        message(STATUS "OpenMP not found - parallel processing disabled")
        set(OPENMP_AVAILABLE FALSE)
    endif()
endif()

# Add subdirectories
if(BUILD_PYTHON_BINDINGS)
    add_subdirectory(src/am_qadf_native)
endif()

# Install rules
if(BUILD_PYTHON_BINDINGS)
    install(TARGETS am_qadf_native
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin
    )
endif()

# Testing support: full project build includes C++ tests when BUILD_TESTS=ON.
# You can still build only the library (BUILD_TESTS=OFF) or build tests separately
# (e.g. cmake --build build --target test_voxelization_cpp).
if(BUILD_TESTS)
    enable_testing()
    # Python smoke test (am_qadf_native import)
    add_test(NAME am_qadf_native_test
        COMMAND ${Python3_EXECUTABLE} -c "import am_qadf_native; print('AM-QADF Native module loaded successfully')"
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
    )
    set_tests_properties(am_qadf_native_test PROPERTIES
        TIMEOUT 30
        LABELS "cpp_extensions"
        ENVIRONMENT "PYTHONPATH=$<TARGET_FILE_DIR:am_qadf_native>"
    )
    # C++ unit tests (link to am_qadf_native_static from src/am_qadf_native)
    add_subdirectory(tests/unit/cpp)
    # C++ integration tests
    add_subdirectory(tests/integration/cpp)
endif()

# Performance benchmarking (optional); C++ benchmarks in tests/performance/cpp/
if(ENABLE_BENCHMARKS)
    find_package(benchmark QUIET)
    if(NOT benchmark_FOUND)
        # FetchContent fallback: no conda package for google/benchmark; fetch from GitHub
        include(FetchContent)
        FetchContent_Declare(
            benchmark
            GIT_REPOSITORY https://github.com/google/benchmark.git
            GIT_TAG        v1.8.3
        )
        set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL "" FORCE)
        set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL "" FORCE)
        FetchContent_MakeAvailable(benchmark)
    endif()
    if(TARGET benchmark::benchmark)
        message(STATUS "Google Benchmark found - performance testing enabled")
        add_subdirectory(tests/performance/cpp)
    else()
        message(STATUS "Google Benchmark not found - performance benchmarks skipped")
    endif()
endif()

# Print comprehensive configuration summary
message(STATUS "")
message(STATUS "==========================================")
message(STATUS "AM-QADF Native C++ Configuration Summary")
message(STATUS "==========================================")
message(STATUS "  Project version: ${PROJECT_VERSION}")
message(STATUS "  Build type: ${CMAKE_BUILD_TYPE}")
message(STATUS "  C++ standard: ${CMAKE_CXX_STANDARD}")
message(STATUS "  Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
message(STATUS "  Python executable: ${Python3_EXECUTABLE}")
message(STATUS "  Python version: ${Python3_VERSION}")
message(STATUS "  pybind11 found: ${pybind11_FOUND}")
message(STATUS "  OpenVDB found: ${OpenVDB_FOUND}")
message(STATUS "  ITK found: ${ITK_FOUND}")
message(STATUS "  Eigen found: ${EIGEN3_FOUND}")
message(STATUS "  KFR found: ${KFR_FOUND}")
if(mongocxx_FOUND)
    message(STATUS "  mongocxx found: TRUE")
else()
    message(STATUS "  mongocxx found: FALSE")
endif()
if(TBB_FOUND OR TBB_INCLUDE_DIR)
    message(STATUS "  TBB found: TRUE")
else()
    message(STATUS "  TBB found: FALSE")
endif()
message(STATUS "  OpenMP available: ${OPENMP_AVAILABLE}")
if(OpenMP_CXX_FOUND)
    message(STATUS "  OpenMP version: ${OpenMP_CXX_VERSION}")
endif()
message(STATUS "  Sanitizers enabled: ${ENABLE_SANITIZERS}")
message(STATUS "  Coverage enabled: ${ENABLE_COVERAGE}")
message(STATUS "  Profiling enabled: ${ENABLE_PROFILING}")
message(STATUS "  Benchmarks enabled: ${ENABLE_BENCHMARKS}")
message(STATUS "  Build Python bindings: ${BUILD_PYTHON_BINDINGS}")
message(STATUS "  Build tests: ${BUILD_TESTS}")
message(STATUS "==========================================")
message(STATUS "")
